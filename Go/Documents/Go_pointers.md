> 译自：[Go Pointers](https://go101.org/article/pointer.html)

# Go指针

Go吸收了其他语言的各种特性，但还是被视作为类C语言。 其中一项就是Go支持指针。 Go指针和C指针在很多方面都很类似， 但也有一些不同的地方。 这篇文章将会剖析Go指针相关的概念和原理。

## 内存地址

内存地址表示从OS管理的整个内存的起始点的偏移量（字节数）。

通常来说， 内存地址存储为无符号整型字（word）。 本地字（word）在32位平台上为4个字节， 在64位的平台上为8个字节。 因此理论上最大的内存空间为2^32个字节， 在32位的平台上为4GB（1GB == 2^30字节），在64位平台上为 2^32GB。

内存地址通常用16进制表示， 比如 `0x1234CDEF`。

## 值得地址

值的地址表示由值的[直接部分direct part](https://go101.org/article/type-system-overview.html#value-part)所占有的内存段的起始地址。

[值部分value parts](https://go101.org/article/value-part.html)文章将会介绍哪些类型可能拥有间接的底层类型的值。

## 什么是指针

指针是一个用来存储内存地址的特殊值。 事实上， 我们经常称内存地址为指针， 反之亦然。

通常，存储在指针中的内存地址是另一个值的地址。 不同于C语言， 由于安全因素的考虑， Go指针有一些限制。 下面将会详述这些限制。

## Go指针的类型和值

和C语言的指针一样， 一个未命名的指针类型可以表示为 `*T`， 其中 `T` 可以是任意类型。 类型 `T` 被称为指针类型 `*T` 的基本类型。

我们也可以声明命名指针类型， 但是通常来说不推荐这么做。 未命名的指针类型在可阅读性方面优于命名指针类型。

如果一个已经定义过的指针的[底层类型](https://go101.org/article/type-system-overview.html#underlying-type) 是 `*T`。 则定义的指针类型的就基本类型是 `T` 。两个具有相同基本类型的未定义指针类型是相同的。

例子：

```go
*int  // 未命名的指针类型的基类型是 int
**int // 多层未命名的指针类型的基类型是 *int

type Ptr *int // 命名的指针类型的基类型是 int
type PP *Ptr  // 基类型是 Ptr
```

任何指针类型的零值都是 `nil`， 没有地址存储在nil指针里。

基类型为 `T` 的指针类型的指针值可以被称为 `T` 指针。 位于非零(non-nil)指针处的值将始终被编译器视为类型 `T` 的值。

## 如何获取指针值？ 什么是可寻址的值

有两种方式可以获取到非零指针的值：

1. 内建函数 `new` 可以为任意类型分配内存。 `new(T)` 可以为`T`值分配内存并且返回`T`值得地址。分配的值是类型`T`的零值。 返回的地址的是类型`*T`的指针值。

2. 也可以用另外一种方式在Go中获取值的地址。可以取到地址的值被称为可寻址的值。 对于一个可寻址的类型`T`的`t`值来说， 我们可以使用表达式`&t`来获取`t`的地址， `&`操作符是取址符。 &t的类型是`*T`。


Go中所有的变量都是可寻址的， 所有的常量都是不可寻址的。 Go中并不是所有存储在内存中的值在运行时都可以寻址。我们可以在之后的文章中学习到其他可寻址和不可寻址的值。 可以通过文章[summary](https://go101.org/article/summaries.html#not-addressable)获取Go中可寻址和不可寻址的值得列表。


尽管可寻址的值可以被修改， 但它们的地址在整个值的生命周期中是不可变的。

## 指针的反引用（逆向引用，取指针的值）

给定一类型为`Tp`的指针值`p`， 如何获取到存储在指针中的地址对应的值？使用表达式`*p`就可取到该值，`*` 被称为逆向引用操作符。 `*p` 被称为指针`p`的逆向引用。 指针逆向引用是取址的反操作。`*p` 的结果是`Tp`基类型的值。
