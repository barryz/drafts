# RabbitMQ 持久化配置

标签（空格分隔）： RabbitMQ Linux

---

### 持久化配置
  RabbitMQ持久化层旨在没有配置的大多数情况下(默认配置)给出一个良好的结果。然而，有些配置还是很有必要的。
  
#### 持久化是如何工作的
  首先，有一个背景，持久化和非持久化的消息都可以写入磁盘。持久化消息在消息到达队列的时候就写入磁盘，而非持久化的消息仅在内存有压力情况下才会把消息逐出内存写入磁盘。持久化的消息尽可能地会保存在内存中，并在内存有压力的情况下，才会清除出内存。“持久层”是指用于将两种不同类型的消息存储到磁盘的机制。
  
  这里所说的“队列”指的是未镜像的队列，或者一个master队列(slave队列)。队列的镜像发生在上述队列持久化之上。
  
  持久层有两个组件： queue index(QI)和 message store。 queue index 负责维护给定的消息在队列中_位置_相关的信息，以及它是否已经被_投递_或_确认_的信息(状态)。因此每个队列都有一个queue index。
  
#### 内存开销
  在内存有压力情况下，持久层尽可能多地尝试将消息写入磁盘，并尽可能地从内存中删除消息。但是有些东西必须留在内存中：
  
  - 每个队列为每个unacknowledged的消息维护了一些元信息。这些消息本身自己可以从内存中删除，若消息的目的地是message store的话。
  - 消息存储需要一个索引，默认消息存储索引对存储中的每个消息都会使用少量内存。

#### 队列索引中的消息
  将消息写入队列索引的优缺点：
优点：
  
  - 消息可以一次操作（而非两次）即可写入磁盘，这对于小消息体来说非常有益。
  - 写入队列索引的消息并不需要消息存储索引中的条目，因此在分页（paging out）时不具有内存成本。
  
缺点：

  - 队列索引保留一个固定数量的在内存中的记录块； 如果非常小的消息被写入队列索引，则对内存的使用开销将会非常巨大。
  - 如果一条消息被交换器路由到了多个队列，则此条消息会被写入多个队列索引。如果这条消息被写入到消息存储内，那么仅有一条这样的消息拷贝被写入。
  - 目的地是队列索引的未确认的消息会始终保存在内存中。
 
我们主要的目的是将非常小的消息作为优化存储到队列索引中，并且其他所有消息将会写入消息存储。这是被此项配置项`queue_index_embed_msgs_below`控制的。默认的，序列化之后大小小于4096字节（包括 properties 和 headers）的消息存储到队列索引中。

每个队列索引在从磁盘中读取消息时需要在内存中保留至少一个段文件。一个段文件包括了`16384`条消息记录。因此应该小心增加`queue_index_embed_msgs_below`的值，一个很小的增量就会导致很大的一笔内存开销。

### Accidentally limited persister performance
  持久化可能会表现不佳，因为持久性在其必须使用的文件句柄或异步线程的有数量限制。在这两种情况下， 如果有大量的队列需要访问磁盘，则会发生性能表现不佳的情况。
  
#### **Too few file handles**（文件句柄太少）
  RabbitMQ服务器一般会限制它可以打开的文件句柄数。每个运行中的网络连接都需要一个文件句柄，并且剩下的会被队列们使用。如果在考虑完网络连接之后，存在着比文件句柄更多的磁盘访问队列，则磁盘访问队列将在它们之间共享文件句柄； 每个队列都在使用文件句柄一段时间之后，然后被回收并给予另一个队列使用。
  
  这样做防止了服务器因为有太多的磁盘访问队列而崩溃，但是这确实非常昂贵的。管理插件能够展示集群中每个节点的`I/O statistics`；以及显示`reads`，`writes`，`seeks`，`syncs`等的速率，它也将显示`reopen`的速率 - 文件句柄以这种方式被回收的速率。 具有过少的文件句柄的繁忙的服务器可能会每秒执行上百个`reopen`操作 - 在此种情况下，如果设置更多的文件句柄，其性能可能会显著增加。
  
#### **Too few async threads**
  Erlang虚拟机创建一个异步线程池用以处理耗时运行的文件I/O操作。这些异步线程会在所有队列之间共享。每个活动的文件I/O操作在发生时会使用一个异步线程。过少的异步线程数会损坏性能。
  
  需要注意的是， 异步线程的情况并不类似于具有文件句柄问题的情况。如果队列按顺序执行多个I/O操作，且是在同一个文件句柄上执行这些操作，那么它将会有上佳性能表现；否则可能会造成过多的`flush` 和 `seek` 操作，并且额外的需要CPU去编排它们。但是，队列不会从跨操作序列持有的异步线程中获益（事实上，也不能这么做）。
  
  因此，对于正在执行I/O操作流的所有队列以及在存储层可以执行的并发I/O操作数量的足够的异步线程，理想情况下应该有足够的文件句柄去支持。
  
  当缺少足够多的异步线程导致的性能问题，不会明显出现。（一般情况下也不太可能，请先检查其他事情）。异步线程过少导致的典型症状包括当服务器忙于持久化，而每个I/O操作的报告时间增加，导致每秒I/O操作次数短时间内下降到零，
  
  异步线程的数量由`+A`参数配置到Erlang虚拟机， 具体描述请看[这里][async thread]，并通过环境变量`RABBITMQ_SERVER_ERL_ARGS`配置。 默认值为`+A 30`。在更改之前，一个更好的建议是多尝试几个值。
  
### Alternate message store index implementations（备用消息存储索引的实现）
  如上所述，写入消息存储的每条消息使用少量的内存用于其索引条目。消息存储索引在RabbitMQ是可插入的。需要注意的是这种插件通常会拖慢消息存储。
  
  
[async thread]: http://www.erlang.org/doc/man/erl.html#async_thread_pool_size
